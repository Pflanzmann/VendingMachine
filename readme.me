s0569420 | Ronny Brzeski | https://github.com/Pflanzmann/VendingMachine

Programmieren 3 - VendingMachine

Es sind 4 Main-Methoden im Package */com/vending/mains gegeben, welche die geforderten Aufgaben wiederspiegeln.

Main_CLi        ->  Startet eine CLI welche nur über Events und Observer mit der VendingMachine kommuniziert.

Main_GUI        ->  Startet eine GUI welche über Stream mit einer CLI kommuniziert, welche wiederum über Events und
                    Observer mit der VendingMachine kommuniziert.

Main_TCP_Server ->  Startet einen Server, welcher versucht sich über 3 TCP Verbindungen mit einem Client zu
                    verbinden. Der Server benutzt eine CLI, welche mit den Sockets verbunden ist um die VendingMachine
                    so über Events und Observer zu kontrollieren.

Main_TCP_Client ->  Startet einen Client, welcher versucht sich über 3 TCP Verbindungen mit einem Server, aus dem
                    LocalHost, zu verbinden. Zum Steuern des Clienten wird die normale GUI verwendet.

Sonstige Anmerkungen:
Die extra Anforderungen sind erfüllt. Kuchen sind nach dem Decorator-Pattern designt. Die parametrisierbare Suche
ist auch umgesetzt. Sie returnt eine Liste von Kuchen die zu den gesetzten Parameter passen.

Jede CLI bekommt einen Printstream für den Output ihrer Informationen. Selbst CLI´s welche nur als Kopplung für andere
Komponenten dienen bekommen den normalen System.out Stream, da man so den Ablauf des Programms besser nachvollziehen
kann, unabhängig von der Art und Weise wie sie angesprochen wird.

Fehlermeldungen werden nicht and den Client oder die CLI gesendet, da dafür ein weiteres Event, bzw ein weiterer Stream
nötig wär um dies umzusetzen. Aus aufwands Gründen und weil es nirgendwo irgendwie beschrieben war habe ich mich dafür
entschieden dies nicht umzusetzen.

Eine Ideale Umsetzung der Kommunikationen zwischen den Streams wär über einen einzigen Stream mit einem Payload-System.
Da hierfür Java genutzt wurde und dies meiner Meinung nach nicht schön umzusetzen geht, habe ich mich hier dafür
entschieden es mit 3 Streams zu machen.

Dinge wie die RemoteStartCli Klasse oder andere StartUp Klassen habe ich aus Aufwandsgründen nicht getestet, da dies
einfach nur für die Vereinfachung des Startvorgangs ist.

UDP -Client/ -Server habe ich nicht hinzugefügt, genauso wie das Drag und Drop, da dies nur mühsam passen würden und
ich aus Zeitgründen darauf verzichten musste.

Das Speichern des Verkausautomaten mit JavaBeans Persistance habe ich auch weggelassen, da mir absolut unklar war
welchen Vorteil das zu der normalen java Serialisierung bringen soll. Außerdem habe ich in der VendingMachine Klasse
zwei Methoden zum Serialisieren/ Deserialisieren und bin dadurch nicht in der Lage gewesen dies angenehm durch JBP zu
ersetzen. Bestenfalls hätte man dies von dem Verkausautomat komplett wegkapseln sollen indem man dies durch eine
Art StorageManager injected, was ich diesmal nicht gemacht habe, da ich sonst den Verkaufsautomat hätte groß umbauen
müssen.

Den GuiController konnte ich nicht so einfach testen und habe mich damit auch nicht beschäftigt, da in der Aufgabe
auch stand, dass dies nicht nötig sei. Da die Mehrheit der Methoden des GuiControllers private sind und vom FXMLLoader
injected werden, war das jetzt suboptimal.

Die Simulation hat für jede genutzte Klasse einen Test, da in der Aufgabe auch nur von einem Test die Rede war und ich
aus Zeitgründen einen Schritt zurücktreten musste.

Außerdem ist die Simulation bei mir endlich. Ich konnte der Aufgabe nicht genau entnehmen wohin die 3 Auslagerungs-
threads auslagern sollen und habe sie jeweils einen Slot weiter auslagern lassen, sodass diese bei der Verteilung
helfen. Die Auslagerungsthreads können aber jederzeit mit neuen Auslagerungsautomaten bestückt werden, sodass man
dies erweitern kann. Die Einlagerungsthreads sind so designt, dass sie aufhören sobald alle Automaten die sie kennen
voll sind.
